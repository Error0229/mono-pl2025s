# 8. Goroutine 洩漏與取消
若 goroutine 因無人接收通道而永久阻塞，就會形成 goroutine 洩漏。可利用 `done` 通道或 `context.Context` 控制生命週期：

```go
done := make(chan struct{})

func worker() {
    for {
        select {
        case <-done:
            return
        default:
            // 執行任務
        }
    }
}

// 關閉 done 讓所有 worker 停止
close(done)
```

A goroutine leak occurs when a goroutine is blocked forever, often on a channel send or receive. The book suggests using a `done` channel or `context.Context` to signal cancellation. All goroutines should select on this channel and exit promptly when it is closed so resources are released.

