### Prolog 期末考學習筆記

本筆記旨在提供期末考中 Prolog 相關內容的綜合性回顧，涵蓋了狀態空間搜尋、啟發式搜尋 (A*)、可允許性、以及各種 Prolog 語言特性和常用內建述詞。

#### 一、狀態空間 (State Space) 搜尋與啟發式搜尋 (Heuristic Search)

**1. 狀態空間表示 (State Space Representation)**
*   在 Prolog 中，問題通常被表示為一個「狀態空間」，這是一個由節點（狀態）和連接節點的邊（行動）組成的圖。
*   一個狀態可以由結構 `s(X,Y)` 或 `s(X,Y,C)` 來表示，其中 `X, Y` 代表狀態的資訊，`C` 可能代表從起始狀態到該狀態的成本。
*   **起始節點 (Start Node)**：搜尋的起點。
*   **目標節點 (Goal Nodes)**：由一個「目標條件」定義的狀態，表示問題的解決。

**2. 啟發式搜尋 (Heuristic Search)**
*   **A\* 演算法 (Algorithm A\*)**：A\* 是一種最佳優先搜尋 (Best-First Search) 演算法，其目標是找到通過節點 `n` 的最佳解的估計成本 `f(n)`。
    *   **成本函數 `f(n)`**：`f(n) = g(n) + h(n)`。
        *   **`g(n)`**：從起始狀態（或 RTA\* 中的當前狀態）到節點 `n` 的實際路徑成本。
        *   **`h(n)`**：從節點 `n` 到最接近目標節點的估計路徑成本，這是一個已知的啟發式猜測。
*   **樹表示法**：在 A\* 搜尋中，樹可以用 `l(N, F/G)` (葉節點) 或 `t(N, F/G, Subs)` (分支節點) 來表示。
*   **節點擴展 (Node Expansion)**：
    *   節點的子樹會根據其 `f` 值進行排序。
    *   具有最小 `f` 值的子樹會優先在指定「限制 (Bound)」內擴展。
    *   **擴展停止條件**：當找到一個目標節點時，擴展停止，並繼續尋找解決方案。
    *   **擴展行為**：
        *   如果遇到葉節點，會添加新的「邊緣樹 (fringe trees)」。
        *   如果節點 `f` 值超出「限制」，則擴展停止，該樹會返回到等待佇列中，根據其 `f` 值重新排序。
        *   如果沒有可擴展的樹，則擴展永不發生。
    *   **`continue` 動作**：如果 `continue` 返回 `yes`，表示找到了解決方案。如果返回 `no`，表示該樹返回等待佇列；如果返回 `never`，表示該樹被剪枝。
*   **`s(N,M,C)` 和 `h(N)` 嵌入 A\***：這表示狀態空間中的移動成本 `C` 和啟發式函數 `h(N)` 如何融入 A\* 演算法的實現中。

**3. 啟發式搜尋的變體與相關概念**

*   **RTA\* (Real-Time A\*)**
    *   **規劃與執行交錯**：在 RTA\* 中，規劃階段和執行階段是交錯進行的。
    *   **當前狀態 (Current State)**：與傳統 A\* 不同，RTA\* 中的 `g(n)` 和 `f(n)` 是相對於「當前狀態」（實際物理狀態）來衡量的，而不是起始狀態。
    *   **固定深度預測 (Fixed Depth Lookahead)**：從當前狀態通過固定深度預測來評估後繼者。
    *   **已訪問節點 (Visited Nodes)**：會儲存 `f(s) := f(second_best_f) + cost(s,best_s)` 的值。這樣，如果最佳後繼者事後證明不好，問題解決者可以返回 `s` 並考慮第二最佳後繼者，同時計入從 `s` 移動到最佳後繼者的成本。
    *   **目標節點的啟發式**：如果在預測中遇到目標節點 `n`，則 `h(n) = 0`。
*   **Alpha 剪枝 (Alpha-pruning)**
    *   如果啟發式函數 `f` 是「單調 (monotonic)」的，則可以進行 Alpha 剪枝。
    *   **條件**：如果 `f(n) >= best_f`（`best_f` 是到目前為止在預測範圍內找到的最佳 `f` 值），那麼節點 `n` 的子樹可以被剪枝。
    *   **單調性影響**：如果 `f` 是單調的，則 `n` 的所有後代都將具有 `f >= alpha`。
    *   **常見的單調啟發式**：曼哈頓距離 (Manhattan distance) 和歐幾里得距離 (Euclidean distance) 通常是單調的。
*   **IDA\* (Iterative Deepening A\*)**
    *   一種節省空間的最佳優先搜尋技術，其理念類似於迭代加深 (Iterative Deepening)。
    *   迭代加深重複執行深度優先搜尋 (DFS)，並逐漸增加深度限制。
    *   IDA\* 則重複執行深度優先搜尋，並逐漸增加 `f` 值限制。
    *   **演算法流程**：
        1.  初始化 `Bound := f(StartNode)`。
        2.  `SolutionFound := false`。
        3.  重複執行以下步驟直到 `SolutionFound` 為 `true`：
            *   執行從 `StartNode` 開始的深度優先搜尋，但只擴展 `f(N) <= Bound` 的節點 `N`。
            *   如果這次深度優先搜尋找到一個 `f <= Bound` 的目標節點，則 `SolutionFound = true`。
            *   否則，將新的 `Bound` 設定為：`min { f(N) | N generated by this search, f(N) > Bound }`。
*   **可允許性 (Admissibility)**
    *   一個搜尋演算法是可允許的，如果它保證總是能找到「最佳解決方案」。
    *   A\* 演算法在 Hart、Nilsson 和 Raphael 於 1968 年提出的可允許性定理中被證明是可允許的。
    *   **任務排程的啟發式函數**：對於任務排程問題，有一個啟發式函數定義為 `h = max(Finall - Fin, 0)`，其中 `Fin` 是處理器當前任務的最大完成時間，`Finall = (SUMW(DW) + SUMJ(FJ)) / m`（`W` 為等待中的任務，`DW` 為等待任務的持續時間，`m` 為處理器數量）。該來源提出了這個啟發式函數是否可允許的問題。

#### 二、Prolog 程式設計基礎

**1. 資料物件 (Data Objects)**
*   Prolog 中的所有資料物件都是「項 (terms)」。
*   **簡單物件 (Simple Objects)**：
    *   **原子 (Atoms)**：以小寫字母開頭的字母、數字、底線組成的字串，或特殊字元組成的字串（除了 `:-`），或單引號括起來的字串。例如：`anna`, `'Tom'`, `---`。
    *   **數字 (Numbers)**：整數 (e.g., `1313`, `-97`) 和實數 (e.g., `3.14`, `-0.0035`)。
*   **變數 (Variables)**：以大寫字母或底線開頭的字串。例如：`X`, `Result`, `_x23`, `_23`。
    *   **匿名變數 (Anonymous variables)**：用單個底線 `_` 表示，表示不關心變數的具體值。例如：`hasachild(X) :- parent(X, _)`。
    *   **詞法作用域 (Lexical Scope)**：變數名稱的作用域僅限於單一子句；同一個子句內，相同的變數名稱指代同一個變數。不同子句中的相同變數名稱則指代不同的變數。原子則在整個程式中都指代相同的物件。
*   **結構 (Structures)**：由一個「函子 (functor)」和一組「參數 (arguments)」組成的複合物件，可以表示為樹狀結構。函子由名稱和「元數 (arity)」（參數數量）定義。例如：`date(Day, may, 2001)`。

**2. 匹配 (Matching)**
*   Prolog 中 unification 的過程稱為匹配。
*   **規則**：
    *   如果 `S` 和 `T` 是常數，則只有當它們是相同的物件時才匹配。
    *   如果 `S` 是變數，`T` 是任何東西，則它們匹配，並且 `S` 會被實例化為 `T`。
    *   如果 `S` 和 `T` 是結構，則只有當它們有相同的「主函子 (principal functor)」（名稱和元數都相同），且所有對應的參數都匹配時才匹配。
*   匹配會產生「最一般實例化 (most general instantiation)」，為後續的實例化留下最大的自由度。

**3. 清單 (Lists) 和清單操作**
*   **表示**：清單是項的序列，可以是空的 `[]`，或由 `[頭元素 | 尾清單]` 組成。例如：`[ann, tennis, tom, skiing]` 或 `.(ann, .(tennis, .(tom, .(skiing, []))))`。
*   **成員關係 (Membership)**：`member(X, L)`，檢查 `X` 是否在清單 `L` 中。可以遞歸定義。
*   **串接 (Concatenation)**：`conc(L1, L2, L3)`，將 `L1` 和 `L2` 串接成 `L3`。
*   **添加項目 (Adding an item)**：最簡單的方式是將新項目放在清單前面，形成 `[X|L]`。
*   **刪除項目 (Deleting an item)**：`del(X, L, L1)`，將 `L` 中的 `X` 移除得到 `L1`。`del` 是非確定性的，也可以用於插入。
*   **子清單 (Sublist)**：`sublist(S, L)`，如果 `S` 是 `L` 的子清單。可透過 `conc` 定義。
*   **排列 (Permutations)**：`permutation(List, PermutedList)`，生成清單的各種排列。可以遞歸定義。

**4. 運算子 (Operators)**
*   運算子可以採用中綴 (infix)、前綴 (prefix) 或後綴 (postfix) 形式。
*   **定義**：使用 `:- op(Precedence, Type, Name).` 指令定義新運算子。
    *   `Precedence`：整數 (通常 1 到 1200)，值越高綁定越鬆散（先執行綁定緊的）。
    *   `Type`：指定運算子位置（`f` 函子，`x` 參數優先級嚴格小於運算子，`y` 參數優先級小於或等於運算子），例如 `xfx`, `xfy`, `fx`, `fy`。
*   運算子定義僅引入新符號，不定義任何操作或行為。
*   Prolog 標準庫中預定義了許多運算子，例如算術運算子、比較運算子和邏輯非 `not`。

**5. 算術 (Arithmetic)**
*   **基本算術運算子**：`+`, `-`, `*`, `/`, `**` (冪), `//` (整數除法), `mod` (餘數)。
*   **`is` 述詞**：`X is Expr`，`X` 會被實例化為算術表達式 `Expr` 的值。例如：`X is 1+2` 會使 `X` 為 `3`。
*   **比較運算子**：`>`, `<`, `>=`, `=<`。還有 `=:=` (數值相等) 和 `=\=` (數值不等)。
*   **內建函數**：`sin(X)`, `cos(X)`, `log(X)`, `exp(X)` 等。
*   **範例**：`gcd` (最大公約數) 和 `length` (清單長度) 的定義。

**6. 宣告式 (Declarative) 與程序式 (Procedural) 意義**
*   **宣告式意義 (Declarative Meaning)**：
    *   關注程式所定義的「關係」本身。
    *   決定給定目標是否為真，以及在什麼變數值下為真。
    *   程式設計師應主要關注此層次，以確保邏輯正確性。
*   **程序式意義 (Procedural Meaning)**：
    *   決定如何獲得輸出，即 Prolog 系統如何實際評估這些關係。
    *   包括 Prolog 如何搜尋證明序列、子句的選擇順序、目標的處理順序以及回溯機制。
    *   **執行流程**：Prolog 嘗試滿足所有目標。當遇到一個目標 `G1` 時，它會從上到下掃描程式中的子句，直到找到一個頭部與 `G1` 匹配的子句 `C`。然後將 `G1` 替換為 `C` 的主體，形成新的目標清單，並遞歸執行。如果找不到匹配或執行失敗，Prolog 會回溯。
    *   **子句和目標的順序**：在宣告式意義上，子句和目標的順序不影響程式的邏輯正確性。然而，在程序式意義上，順序會極大地影響程式的效率，甚至可能導致無限循環或堆疊溢位。最佳實踐是「通常先嘗試最簡單的解決方案」。

**7. 控制回溯 (Controlling Backtracking)**
*   Prolog 會自動回溯以尋找所有可能的解。但有時需要控制或阻止回溯以提高效率。
*   **剪枝操作符 `!` (Cut)**：
    *   `H :- B1, ..., Bm, !, ..., Bn.`。
    *   當執行到 `!` 時，它會「凍結 (frozen)」`B1, ..., Bm` 的當前解，並丟棄所有其他替代方案。
    *   同時，`!` 會使父目標 `G` (調用 `H` 的目標)「綁定 (committed)」到此子句，阻止 Prolog 嘗試 `G` 的其他子句。
    *   **綠色剪枝 (Green Cuts)**：不影響程式的宣告式意義，只影響效率。
    *   **紅色剪枝 (Red Cuts)**：會改變程式的宣告式意義，應謹慎使用。
    *   **範例**：`f(X,Y)` 函數、`max(X,Y,Max)`、只尋找第一個匹配項的 `member`、不重複添加元素的 `add`。
*   **`fail` 述詞**：一個總是失敗的目標，用於強制父目標失敗。常與 `!` 結合使用 (`!, fail`)。
*   **`not(Goal)` 述詞 (Negation as Failure)**：
    *   如果 `Goal` 不為真，則 `not(Goal)` 為真。其行為定義為 `not(P) :- P, !, fail; true.`。
    *   **應用**：定義「瑪麗喜歡所有動物但蛇」的關係，定義 `difference(X, Y)`，分類網球選手 (`class/2`)，八皇后問題的變體。
    *   **問題**：`not` 基於「失敗即否定 (negation as failure)」的假設，即無法證明為真的就是假的。如果 `not Goal` 被調用時 `Goal` 中的變數尚未實例化，可能會導致意想不到的結果。

**8. 輸入和輸出 (Input and Output)**
*   **檔案通訊**：
    *   `see(File)`：將當前輸入流重定向到 `File`。
    *   `tell(File)`：將當前輸出流重定向到 `File`。
    *   `seen`：關閉當前輸入流並返回 `user`。
    *   `told`：關閉當前輸出流並返回 `user`。
*   **讀寫項 (Processing files of terms)**：
    *   `read(X)`：從當前輸入流讀取下一個項，並嘗試與 `X` 匹配。讀到檔案末尾時 `X` 會被實例化為 `end_of_file`。
    *   `write(X)`：將項 `X` 輸出到當前輸出流。
*   **格式化輸出**：
    *   `tab(N)`：輸出 `N` 個空格。
    *   `nl`：輸出換行符。
*   **讀寫字元**：
    *   `get0(C)`：讀取下一個字元的 ASCII 碼。
    *   `put(C)`：寫入 ASCII 碼 `C` 對應的字元。
*   **操作原子 (Manipulating atoms)**：
    *   `name(Atom, ListOfASCII)`：`ListOfASCII` 是 `Atom` 中字元的 ASCII 碼清單。可用於分解或建構原子。
    *   **範例**：`getsentence(Wordlist)` 用於將自然語言句子轉換為原子清單。

**9. 讀取程式 (Reading Programs)**
*   **`consult(File)`**：將 `File` 中的所有子句讀取並載入到記憶體中。
*   可以一次 `consult` 多個檔案，例如 `?- [program3, program4, queens].`。
*   GNU Prolog 編譯器 `gplc` 可用於將 Prolog 原始碼編譯為可執行檔。

**10. 更多內建述詞 (More Built-in Predicates)**
*   **測試項的類型 (Testing the type of terms)**：
    *   `var(X)`：如果 `X` 是未實例化的變數，則成功。
    *   `nonvar(X)`：如果 `X` 不是變數或已實例化，則成功。
    *   `atom(X)`：如果 `X` 是原子，則成功。
    *   `integer(X)`：如果 `X` 是整數，則成功。
    *   `float(X)`：如果 `X` 是實數，則成功。
    *   `number(X)`：如果 `X` 是數字（整數或實數），則成功。
    *   `atomic(X)`：如果 `X` 是數字或原子，則成功。
    *   `compound(X)`：如果 `X` 是複合項（結構），則成功。
    *   **應用**：`count/3` 統計原子在清單中出現的次數。密碼算術謎題的解決中用 `nonvar` 判斷變數是否已實例化。
*   **建構和分解項 (`=..`, `functor`, `arg`)**：
    *   `Term =.. List`：如果 `List` 是一個清單，其包含 `Term` 的主函子，後面接著其參數，則為真。常用於動態建構和調用目標。
    *   `functor(Term, F, N)`：如果 `F` 是 `Term` 的主函子，`N` 是 `F` 的元數，則為真。
    *   `arg(N, Term, A)`：如果 `A` 是 `Term` 的第 `N` 個參數，則為真 (參數從 1 開始編號)。
    *   **應用**：`enlarge/3` (縮放幾何圖形)、`substitute/4` (在項中替換子項)。
*   **各種相等和比較**：
    *   `X = Y`：如果 `X` 和 `Y` 匹配，則為真。
    *   `X is E`：如果 `X` 匹配算術表達式 `E` 的值，則為真。
    *   `E1 =:= E2`：如果算術表達式 `E1` 和 `E2` 的值相等，則為真。
    *   `X == Y`：如果 `X` 和 `Y` 是「詞法上 (term-wise)」相同的項，則為真（不進行實例化）。`X \== Y` 則為不相同。
    *   **字母順序比較**：`X @< Y`, `X @=< Y`, `X @> Y`, `X @>= Y`，用於比較項的字母順序。
*   **資料庫操作 (Database manipulation)**：
    *   Prolog 程式本身可以視為一個資料庫，子句是事實和規則。
    *   **`assert(Clause)`**：將 `Clause` 添加到資料庫。總會成功。
    *   **`asserta(Clause)`**：將 `Clause` 添加到資料庫的「開頭」。
    *   **`assertz(Clause)`**：將 `Clause` 添加到資料庫的「結尾」。`consult` 可以被視為使用 `assertz`。
    *   **`retract(Clause)`**：刪除匹配 `Clause` 的子句。每次調用會刪除一個匹配的子句，並在回溯時尋找並刪除下一個。
    *   **應用**：儲存已計算的答案、生成乘法表。
*   **控制設施 (Control facilities)**：
    *   **`!` (cut)**：阻止回溯。
    *   **`once(P)`**：`once(P) :- P, !.`，只產生一個解。
    *   **`fail`**：總是失敗的目標。
    *   **`true`**：總是成功的目標。
    *   **`not(P)`**：失敗即否定，如上所述。
    *   **`call(P)`**：調用目標 `P`。如果 `P` 成功，則 `call(P)` 成功。
    *   **`repeat`**：一個總是成功的非確定性目標。每次回溯時都會產生另一個替代執行分支。**應用**：通常用於循環結構。
*   **`bagof`, `setof`, `findall`**：
    *   這些內建述詞用於將滿足某個目標的所有物件收集到一個清單中。
    *   **`bagof(X, Goal, List)`**：
        *   `List` 包含所有使 `Goal` 成功的 `X` 值。
        *   如果 `Goal` 沒有解決方案，則 `bagof` 失敗。
        *   包含重複的 `X` 值。
        *   如果 `Goal` 中有變數未與 `X` 共享，`bagof` 會為這些變數的每個獨特實例化產生一個單獨的 `List`。可以使用 `^` 運算符指定不關心這些變數的綁定 (`Age ^ age(Child, Age)`)。
    *   **`setof(X, Goal, List)`**：
        *   類似 `bagof`，但 `List` 會被排序，並且移除重複項目。
        *   處理未共享變數的方式與 `bagof` 相同。
    *   **`findall(X, Goal, List)`**：
        *   將所有使 `Goal` 成功的 `X` 值收集到 `List` 中。
        *   與 `bagof` 的主要區別在於，它會收集所有 `X`，不考慮 `Goal` 中未與 `X` 共享的變數的不同解決方案。
        *   如果沒有 `X` 使 `Goal` 成功，則 `findall` 成功，且 `List` 為空 `[]`。
        *   可以透過 `assertz` 和 `retract` 實現。

**11. Prolog 中的 Lambda 函數 (匿名述詞)**
*   **匿名述詞 (Anonymous predicate)**：可以在程式碼中內聯定義的述詞，通常傳遞給高階述詞 (higher-order predicates) 如 `maplist/2`, `include/3`, `exclude/3`。
*   **語法**： `{CapturedVars} + [Args] >> Goal`。
    *   **`CapturedVars`**：從外部作用域「捕獲」進來的變數清單。
    *   **`[Args]`**：呼叫 lambda 時傳入的參數清單 (類似於函數參數)。
    *   **`Goal`**：lambda 的主體，一個 Prolog 目標，會在 lambda 被呼叫時執行。
*   **範例**：使用 `exclude/3` 移除停用詞 (stop words) 時：`exclude({StopWords}, [W] >> member(W, StopWords), Words, FilteredWords)`。
    *   `{StopWords}` 捕獲了外部作用域的停用詞清單。
    *   `[W]` 是要檢查的輸入單詞。
    *   `member(W, StopWords)` 在 `W` 是停用詞時成功。因為 `exclude` 會移除使述詞成功的元素，所以這個 lambda 會只保留不在 `StopWords` 中的單詞。

#### 三、程式範例與實作細節

*   **八皇后問題 (Eight Queens Problem)**：
    *   **問題**：在 8x8 棋盤上放置八個皇后，使任何皇后都不能攻擊其他皇后。
    *   **三種程式實現 (Program 1, 2, 3)**：展示了不同的資料表示方式和問題解決策略，例如：
        *   程式 1 (Program 1): 使用 `X/Y` 表示棋子的位置，並通過 `noattack` 檢查水平、垂直、對角線攻擊。後續的 `not attacks` 變體更簡潔。
        *   程式 2 (Program 2): 將解決方案表示為列座標的排列，避免檢查垂直攻擊，並通過 `safe` 和帶有距離參數的 `noattack` 檢查對角線攻擊。
        *   程式 3 (Program 3): 利用列、向上對角線、向下對角線這三個域來進行搜尋，每次放置一個皇后就從這三個域中刪除對應的值。

**程式 1：使用 X/Y 表示位置**
```prolog
% 使用 X/Y 表示棋子的位置
solution([]).
solution([X/Y | Others]) :-
    solution(Others),
    member(Y, [1,2,3,4,5,6,7,8]),
    noattack(X/Y, Others).

noattack(_, []).
noattack(X/Y, [X1/Y1 | Others]) :-
    Y =\= Y1,           % 不同列
    Y1 - Y =\= X1 - X,  % 不同對角線
    Y1 - Y =\= X - X1,
    noattack(X/Y, Others).

% 使用 not attacks 的變體
solution([]).
solution([X/Y | Others]) :-
    solution(Others),
    member(Y, [1,2,3,4,5,6,7,8]),
    \+ attacks(X/Y, Others).

attacks(X/Y, Others) :-
    member(X1/Y1, Others),
    (Y = Y1;            % 同一列
     Y1 - Y =:= X1 - X; % 同一對角線
     Y1 - Y =:= X - X1).
```

**程式 2：使用列座標排列**
```prolog
% 使用列座標的排列
solution(Queens) :-
    permutation([1,2,3,4,5,6,7,8], Queens),
    safe(Queens).

safe([]).
safe([Queen|Others]) :-
    safe(Others),
    noattack(Queen, Others, 1).

noattack(_, [], _).
noattack(Y, [Y1|Ylist], Xdist) :-
    Y1 - Y =\= Xdist,
    Y - Y1 =\= Xdist,
    Dist1 is Xdist + 1,
    noattack(Y, Ylist, Dist1).
```

**程式 3：使用三個域**
```prolog
% 使用列、向上對角線、向下對角線三個域
solution(Queens) :-
    solution(Queens, [1,2,3,4,5,6,7,8], [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
             [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]).

solution([], _, _, _).
solution([X|Queens], Cols, Diag1, Diag2) :-
    del(X, Cols, Cols1),
    U is X + N,  % 向上對角線
    del(U, Diag1, Diag1_1),
    D is X - N,  % 向下對角線
    del(D, Diag2, Diag2_1),
    solution(Queens, Cols1, Diag1_1, Diag2_1).

del(Item, [Item|List], List).
del(Item, [First|List], [First|List1]) :-
    del(Item, List, List1).
```

*   **猴子與香蕉問題 (Monkey and Banana Problem)**：
    *   **狀態空間搜尋範例**：將猴子的行動表示為狀態之間的轉換 (`move` 述詞)，並使用 `canget` 述詞遞歸地尋找從起始狀態到目標狀態的路徑。
    *   **潛在問題**：此範例也說明了子句和目標順序對程序式意義的影響，錯誤的順序可能導致無限循環。

**猴子與香蕉問題程式碼**
```prolog
% 狀態表示：s(MonkeyPosition, BoxPosition, HasBanana)
% 目標狀態：s(_, _, has)

% 移動規則
move(s(floor, floor, not_has), s(chair, floor, not_has)).
move(s(chair, floor, not_has), s(chair, chair, not_has)).
move(s(chair, chair, not_has), s(chair, chair, has)).

% 遞歸搜尋路徑
canget(State, [State]) :-
    goal(State).

canget(State, [State|Rest]) :-
    move(State, NextState),
    canget(NextState, Rest).

goal(s(_, _, has)).
```

*   **密碼算術謎題 (Cryptarithmetic Puzzle)**：
    *   **DONALD + GERALD = ROBERT**：涉及將不同的十進制數字分配給字母，使加法成立。
    *   **`nonvar` 的應用**：在 `del_var` 述詞中，利用 `nonvar` 判斷變數是否已被實例化，以避免不必要的回溯和數字重複分配。

**密碼算術謎題程式碼**
```prolog
% DONALD + GERALD = ROBERT
puzzle([D,O,N,A,L,D], [G,E,R,A,L,D], [R,O,B,E,R,T]) :-
    % 所有變數必須是不同的數字
    all_different([D,O,N,A,L,G,E,R,B,T]),
    % 第一個字母不能為 0
    D > 0, G > 0, R > 0,
    % 計算 DONALD
    DONALD is D*100000 + O*10000 + N*1000 + A*100 + L*10 + D,
    % 計算 GERALD
    GERALD is G*100000 + E*10000 + R*1000 + A*100 + L*10 + D,
    % 計算 ROBERT
    ROBERT is R*100000 + O*10000 + B*1000 + E*100 + R*10 + T,
    % 檢查等式
    DONALD + GERALD =:= ROBERT.

% 確保所有變數都是不同的
all_different([]).
all_different([X|L]) :-
    \+ member(X, L),
    all_different(L).

% 使用 nonvar 的變體
del_var(X, L, L1) :-
    nonvar(X), !,
    del(X, L, L1).
del_var(_, L, L).
```

**A* 演算法實現**
```prolog
% A* 演算法的基本實現
bestfirst(Start, Solution) :-
    expand([], l(Start, 0/0), 9999, _, yes, Solution).

% 展開節點
expand(P, l(N, _), _, _, yes, [N|P]) :-
    goal(N).

expand(P, l(N,F/G), Bound, Tree1, Solved, Sol) :-
    F =< Bound,
    (bagof(M/C, (s(N,M,C), \+ member(M,P)), Succ), !,
        succlist(G, Succ, Ts),
        bestf(Ts, F1),
        expand(P, t(N,F1/G,Ts), Bound, Tree1, Solved, Sol)
    ; Solved = never).

expand(P, t(N,F/G,[T|Ts]), Bound, Tree1, Solved, Sol) :-
    F =< Bound,
    bestf(Ts, BF),
    min(Bound, BF, Bound1),
    expand([N|P], T, Bound1, T1, Solved1, Sol),
    continue(P, t(N,F/G,[T1|Ts]), Bound, Tree1, Solved1, Solved, Sol).

expand(_, t(_,_,[]), _, _, never, _) :- !.

expand(_, Tree, Bound, Tree, no, _) :-
    f(Tree, F), F > Bound.

% 繼續搜尋
continue(_, _, _, _, yes, yes, Sol).

continue(P, t(N,F/G,[T1|Ts]), Bound, Tree1, no, Solved, Sol) :-
    insert(T1, Ts, NTs),
    bestf(NTs, F1),
    expand(P, t(N,F1/G,NTs), Bound, Tree1, Solved, Sol).

continue(P, t(N,F/G,[_|Ts]), Bound, Tree1, never, Solved, Sol) :-
    bestf(Ts, F1),
    expand(P, t(N,F1/G,Ts), Bound, Tree1, Solved, Sol).

% 生成後繼節點列表
succlist(_, [], []).

succlist(G0, [N/C | NCs], Ts) :-
    G is G0 + C,
    h(N, H),
    F is G + H,
    succlist(G0, NCs, Ts1),
    insert(l(N,F/G), Ts1, Ts).

% 插入節點到有序列表
insert(T, Ts, [T | Ts]) :-
    f(T, F), bestf(Ts, F1),
    F =< F1, !.

insert(T, [T1 | Ts], [T1 | Ts1]) :-
    insert(T, Ts, Ts1).

% 獲取 f 值
f(l(_,F/_), F).
f(t(_,F/_,_), F).

bestf([T|_], F) :-
    f(T, F).

bestf([], 9999).

min(X, Y, X) :-
    X =< Y, !.

min(X, Y, Y).

% IDA* 實現
ida_star(Start, Solution) :-
    f(l(Start, 0/0), F),
    ida_star_search([], l(Start, 0/0), F, Solution).

ida_star_search(Path, l(N, _), _, [N|Path]) :-
    goal(N).

ida_star_search(Path, l(N, F/G), Bound, Solution) :-
    F =< Bound,
    (bagof(M/C, (s(N,M,C), \+ member(M,Path)), Succ), !,
        succlist(G, Succ, Ts),
        bestf(Ts, F1),
        ida_star_search([N|Path], t(N,F1/G,Ts), Bound, Solution)
    ; Solution = never).

ida_star_search(Path, t(N,F/G,[T|Ts]), Bound, Solution) :-
    F =< Bound,
    bestf(Ts, BF),
    min(Bound, BF, Bound1),
    ida_star_search([N|Path], T, Bound1, Solution).

ida_star_search(_, t(_,_,[]), _, never) :- !.

ida_star_search(_, Tree, Bound, no) :-
    f(Tree, F), F > Bound.

% RTA* 實現
rta_star(Start, Solution) :-
    f(l(Start, 0/0), F),
    rta_star_search(Start, F, infinity, Solution).

rta_star_search(N, F, Bound, Solution) :-
    F > Bound, !,
    Solution = F.

rta_star_search(N, _, _, Solution) :-
    goal(N), !,
    Solution = [N].

rta_star_search(N, F, Bound, Solution) :-
    bagof(M/C, s(N,M,C), Succ), !,
    evaluate_successors(Succ, F, Bound, Solution).

evaluate_successors([S|Ss], F, Bound, Solution) :-
    f(l(S, F/_), F1),
    F1 =< Bound, !,
    rta_star_search(S, F1, Bound, Solution).

evaluate_successors([_|Ss], F, Bound, Solution) :-
    evaluate_successors(Ss, F, Bound, Solution).

% Alpha 剪枝
alpha_prune(N, Alpha, Pruned) :-
    f(N, F),
    (F >= Alpha -> Pruned = yes ; Pruned = no).
```
